
from typing import List, Tuple
from ..algebra.field import FieldElement
from ..algebra.polynomial import Polynomial
from ..algebra.merkle import MerkleTree
import random

class FriLayer:
    def __init__(self, values: List[FieldElement], domain: List[FieldElement]):
        self.values = values
        self.domain = domain
        self.merkle_tree = MerkleTree.commit(values)
        
    @property
    def root(self):
        return self.merkle_tree.root

class FriProver:
    """
    Implements the FRI Protocol (Prover side).
    Prove that a committed polynomial has low degree.
    """
    def __init__(self, polynomial: Polynomial, domain: List[FieldElement]):
        """
        polynomial: The polynomial to prove (usually composition polynomial).
        domain: The evaluation domain (must be power of 2 size).
        """
        self.polynomial = polynomial
        self.domain = domain
        self.layers: List[FriLayer] = []
        
        # Initial evaluation
        values = [polynomial.eval(x) for x in domain]
        self.layers.append(FriLayer(values, domain))

    def generate_proof(self, interaction_channel):
        """
        Run the FRI commit phase.
        interaction_channel: Simulated channel to get random challenges from verifier.
        Returns: list of layer roots, and final constant.
        """
        current_values = self.layers[0].values
        current_domain = self.layers[0].domain
        
        # Send initial root
        interaction_channel.send(self.layers[0].root)
        commitments = [self.layers[0].root]
        
        # Folding
        while len(current_values) > 1: # Until we have a constant (degree 0)
            # 1. Get random beta from Verifier
            # In real non-interactive, this comes from Fiat-Shamir on the previous commitments
            beta = interaction_channel.receive_random_field_element()
            
            # 2. Fold
            # P_next(x^2) = (P(x) + P(-x))/2 + beta * (P(x) - P(-x))/(2x)
            # We fold the DOMAIN first: D_next = {x^2 for x in D_half}
            # Since domain is symmetric group/coset, x and -x are in D.
            
            next_values = []
            next_domain = []
            
            length = len(current_values)
            assert length % 2 == 0
            half_len = length // 2
            
            for i in range(half_len):
                x = current_domain[i]
                # Assuming standard domain ordering where domain[i+half] = -domain[i]
                # If we use roots of unity generated by g, then g^(i+N/2) = -g^i
                x_inv = x.inv()
                
                v_x = current_values[i]
                v_minus_x = current_values[i + half_len]
                
                # Check D[i+half] == -x approximately...
                # assert current_domain[i + half_len] == -x # Costly check, skip for speed
                
                # Formula:
                # even = (v_x + v_minus_x) / 2
                # odd = (v_x - v_minus_x) / (2 * x)
                # combined = even + beta * odd
                
                even = (v_x + v_minus_x) * FieldElement(2).inv()
                odd  = (v_x - v_minus_x) * FieldElement(2).inv() * x_inv
                
                next_val = even + beta * odd
                next_values.append(next_val)
                next_domain.append(x * x)
            
            # 3. Commit to new layer
            layer = FriLayer(next_values, next_domain)
            self.layers.append(layer)
            
            # Send new root
            interaction_channel.send(layer.root)
            commitments.append(layer.root)
            
            current_values = next_values
            current_domain = next_domain
            
        final_constant = current_values[0]
        return commitments, final_constant

    def query_phase(self, indices: List[int]):
        """
        Reveal values for specific indices to allow verification of folding.
        indices: indices in Layer 0 to query.
        Returns: 
           list of (value, path) for each layer corresponding to the indices.
           Note: indices map to next layer by i // 2.
        """
        all_layer_proofs = []
        
        current_indices = indices
        for layer in self.layers[:-1]: # Don't need path for the constant (last layer)
            layer_proofs = []
            for idx in current_indices:
                # Need to reveal idx and its sibling to verify the fold
                # sibling = idx ^ 1 (if we pair 0,1; 2,3 etc)
                # or (idx + length/2) % length if we pair x, -x with standard ordering?
                # In my commit phase I assumed: v_x = values[i], v_minus_x = values[i + half_len]
                # So folding happens between i and i + half_len.
                # So if I query i, I need i + half_len.
                # The next layer index is i.
                
                # Wait, the commit loop was:
                # for i in range(half_len):
                #    pair (i, i+half_len) -> next_layer[i]
                
                # So index `idx` in current layer maps to `idx % half_len` in next layer?
                # Yes. And its partner is `(idx + half_len) % len`.
                
                length = len(layer.values)
                half_len = length // 2
                
                idx_mod = idx % half_len
                partner_idx = (idx + half_len) % length
                
                # Logic: to fold into next_layer[idx_mod], we need layer[idx_mod] and layer[partner_idx].
                # So we must provide paths for BOTH if we want to verify.
                # Or usually, we just provide the value of the partner, because the path is the same/related?
                # Actually, in standard Merkle trees, if leaves are (0,1), (2,3), they are siblings.
                # If my Merkle tree leaves order is just `values`, then `idx` and `partner_idx` are far apart.
                # They are NOT siblings in the Merkle Tree usually.
                # So we need two paths.
                
                # Optimization used in STARKs: Make them siblings in the Merkle Tree by sending the tree as pairs.
                # But my Merkle Tree just commits to the list.
                # So I verify:
                # 1. path for idx
                # 2. path for partner_idx
                
                # Simplified: The verifier asks for index `q`.
                # We reveal `values[q]` and `path[q]`.
                # AND we reveal `values[partner]` and `path[partner]`.
                
                val_idx = layer.values[idx]
                path_idx = layer.merkle_tree.get_authentication_path(idx)
                
                val_partner = layer.values[partner_idx]
                path_partner = layer.merkle_tree.get_authentication_path(partner_idx)
                
                layer_proofs.append({
                    'idx': idx,
                    'val': val_idx,
                    'path': path_idx,
                    'partner_idx': partner_idx,
                    'partner_val': val_partner,
                    'partner_path': path_partner
                })
            
            all_layer_proofs.append(layer_proofs)
            
            # Next layer indices
            current_indices = [idx % (len(layer.values)//2) for idx in current_indices]
            # Remove duplicates for efficiency?
            # current_indices = sorted(list(set(current_indices))) # Actually keep them to match initial queries 1-to-1?
            # Standard: Decommitment is a batch.
        
        return all_layer_proofs 


from typing import List
from ..algebra.field import FieldElement
from ..algebra.merkle import MerkleTree
from .channel import Channel

class FriVerifier:
    def __init__(self, proof, interaction_channel: Channel):
        """
        proof: {
            'commitments': [root0, root1, ...],
            'final_constant': FieldElement,
            'layer_proofs': [ [ {idx, val, path...} ], ... ]
        }
        """
        self.commitments = proof['commitments']
        self.final_constant = proof['final_constant']
        self.layer_proofs = proof['layer_proofs']
        self.channel = interaction_channel

    def verify(self, domain_length, domain_offset=None):
        """
        1. Reconstruct the random betas using the channel (Fiat-Shamir).
        2. Verify paths and folding for each layer.
        """
        if domain_offset is None:
            domain_offset = FieldElement(1)
            
        # 1. Replay Commit Phase to get Betas
        betas = []
        for root in self.commitments[:-1]:
            self.channel.send(root)
            beta = self.channel.receive_random_field_element()
            betas.append(beta)
            
        # Send the last root (final constant commitment) to update state, 
        # but don't draw a beta for it (nothing to fold)
        self.channel.send(self.commitments[-1])
            
        # 2. Verify Query Phase
        # We need the domain for each layer to check folding consistency
        # Assuming domain generation logic is known.
        # Layer 0 domain length = domain_length
        # Using generator g...
        
        # NOTE: In a real implementation, we need the initial domain generator 
        # to check x coordinate.
        # Let's assume passed in or re-derivable.
        # We'll use FieldElement to find generator of order `domain_length`.
        
        g = FieldElement.generator_of_order(domain_length)
        current_domain_gen = g
        current_offset = domain_offset
        current_length = domain_length
        
        # Iterate through layers
        # layer_proofs is list of layers. Each layer has list of queries.
        # We process layer i and check consistency with layer i+1 (which is the start of next loop, or final constant)
        
        for i in range(len(self.layer_proofs)):
            layer_data = self.layer_proofs[i] # List of queries for this layer
            root = self.commitments[i]
            beta = betas[i]
            
            next_layer_queries = {} # Map index -> value for consistency check with next layer
            
            for query in layer_data:
                idx = query['idx']
                val = query['val']
                path = query['path']
                partner_idx = query['partner_idx']
                partner_val = query['partner_val']
                partner_path = query['partner_path']
                
                # 1. Verify Paths
                # Note: MerkleTree.verify_claim needs bytes. 
                # Our tree stored bytes(str(val))
                if not MerkleTree.verify_claim(root, str(val).encode(), path, idx):
                    return False
                if not MerkleTree.verify_claim(root, str(partner_val).encode(), partner_path, partner_idx):
                    return False
                    
                # 2. Verify Folding Relation
                # Calculate what the next value should be
                # x coordinate for idx. 
                # Domain is generated by current_domain_gen with offset. 
                # x = offset * gen^idx
                x = current_offset * current_domain_gen.pow(idx)
                x_inv = x.inv()
                
                # Formula from Prover:
                # even = (v_x + v_minus_x) / 2
                # odd = (v_x - v_minus_x) / (2 * x)
                # combined = even + beta * odd
                
                even = (val + partner_val) * FieldElement(2).inv()
                odd  = (val - partner_val) * FieldElement(2).inv() * x_inv
                next_val = even + beta * odd
                
                # The index in the next layer is idx % (current_length // 2)
                next_idx = idx % (current_length // 2)
                
                # Store expectation for next layer check
                # Note: multiple queries might map to same next_idx, they must match
                if next_idx in next_layer_queries:
                    if next_layer_queries[next_idx] != next_val:
                        return False # Consistency error
                else:
                    next_layer_queries[next_idx] = next_val

            # Prepare for next layer
            current_domain_gen = current_domain_gen.pow(2) # Generator for domain of size N/2 is g^2
            current_offset = current_offset * current_offset # Offset squares too
            current_length //= 2
            
            # Check consistency with NEXT layer actual values
            # If this is the last "proof layer", check against Final Constant?
            # Wait, commitments list usually includes all intermediate layers.
            # If len(commitments) == N, then we folded N times.
            # self.layer_proofs usually stops before the constant?
            # In my Prover:
            # while len > 1: commit, append.
            # Returns commitments and constant.
            
            # Verify that next_layer_queries match what was provided in NEXT layer proof
            if i < len(self.layer_proofs) - 1:
                next_proof_layer = self.layer_proofs[i+1]
                # We need to find the values in next_proof_layer that correspond to our next_idx
                # This is a bit inefficient search O(M^2), but ok for demo.
                for n_idx, n_val in next_layer_queries.items():
                    found = False
                    for q in next_proof_layer:
                        if q['idx'] == n_idx:
                            if q['val'] != n_val:
                                return False
                            found = True
                            break
                        if q['partner_idx'] == n_idx:
                            if q['partner_val'] != n_val:
                                return False
                            found = True
                            break
                    if not found:
                         # It's possible the next layer query set doesn't include this required check?
                         # The prover MUST provide the path for the folded value if we need to verify.
                         # My query_phase logic:
                         # current_indices = [idx % half for idx in current_indices]
                         # So yes, the next layer WILL contain proofs for these next_indices.
                         # But wait, my query_phase reduces indices.
                         # So next_proof_layer SHOULD contain verification for n_idx.
                         return False
            else:
                # This was the last Merkle layer. 
                # The values we computed (next_val) should equal the Final Constant?
                # Yes, if we are fully folded down to degree 0.
                for n_val in next_layer_queries.values():
                    if n_val != self.final_constant:
                        return False

        return True
